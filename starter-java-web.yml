application:
  configuration:
    configuration.scm-uri:  "git://github.com/qubell/starter-java-web.git" 
    configuration.scm-branch:   "master"
    configuration.clusterSize: 1
    compute.hardwareId: "c3.large"
    compute.imageId:    "ami-bf5021d6"
    compute.login:      "root"
    compute.locationId: "us-east-1"
  interfaces:
    configuration:
      scm-uri: "bind(BuildServer#configuration.scm-uri)"
      scm-branch: "bind(BuildServer#configuration.scm-branch)"
      clusterSize: "bind(AppCluster#configuration.quantity, ClusterHarvester#input.clusterSize)"
    compute:
      "*": "bind(Database#compute.*, LoadBalancer#compute.*, AppCluster.AppServer#compute-config.*)"
    petclinic:
      entry-url: "bind(LoadBalancer#haproxy.entry-urls)"
      app-hosts: "bind(ClusterHarvester#result.app-hosts)"
      dbms:      "bind(Database#database.dbms)"
  bindings:
    - [ClusterHarvester, AppCluster.AppServer]
    - [AppDeployer, AppCluster.AppServer]
    - [AppDeployer, Database]
    - [LoadBalancer, AppCluster.AppServer]
    - [AppDeployer, BuildServer]
  components:
    ClusterHarvester:
      type: workflow.Instance
      interfaces:
        input:
          clusterSize: configuration(int)
        tomcat:
          app-host:
             type: consume-signal(string)
             name: Solr host
        result:
          app-hosts: publish-signal(list<string>)
      required: [tomcat]
      configuration:
        configuration.triggers:
          input.clusterSize: update
        configuration.propagateStatus: [ update ]
        configuration.workflows:
          update: &update1
            steps:
              - waitPeers:
                   action: waitPeers
                   parameters:
                     interfaces:
                       tomcat: "{$.clusterSize}"
                     timeout:
                       20 minute
              - get-signals:
                  action: getSignals
                  precedingPhases: [ waitPeers ]
                  parameters:
                    multi: true
                  output:
                    signals: result
            return:
              app-hosts:     { value: "{$.signals.tomcat.*.app-host}"}
          launch: *update1
    AppDeployer:
      type: workflow.Instance
      interfaces:
        input:
          db-sql-url:
            type: configuration(list<string>)
          db-user:
            type: configuration(string)
          db-password:
            type: configuration(string)
          privileges:
            type: configuration(list<string>)
        db:
          dbms:    consume-signal(object)
          db-host: consume-signal(string)
          db-port: consume-signal(int)
          schema:
            type: send-command(string db-user, string db-user-password, list<string> db-user-privileges => object connection)
          file-query:
             type: send-command(object connection, list<string> sql-url)
        build-result:
          war_urls: consume-signal(list<string>)
        actions:
          update: receive-command()
        result:
          java-opts:     publish-signal(string)
          uri:           publish-signal(list<string>)
          path:          publish-signal(list<string>)
          lib-uri:       publish-signal(list<string>)
          context-nodes: publish-signal(object)
          context-attrs: publish-signal(object)
      required: [ db, build-result ]
      configuration:
        input.db-sql-url: ["https://raw.github.com/qubell-bazaar/component-petclinic/master/sql/petclinic-mysql-schema.sql", "https://raw.github.com/qubell-bazaar/component-petclinic/master/sql/petclinic-mysql-dataload.sql"]
        input.db-user: petclinic #const
        input.db-password: petclinic #const
        input.privileges: ["all"] #const
        configuration.triggers:
          build-result.war_urls: update
        configuration.propagateStatus: [ update ]
        configuration.workflows:
          update: &update
            steps:
              - get-signals:
                  action: getSignals
                  output:
                    signals: result
              - manage-schema:
                  action: db.schema
                  precedingPhases: [ get-signals ]
                  parameters:
                    commandCallTimeout: 5 minutes
                    db-user: "{$.db-user}"
                    db-user-password: "{$.db-password}"
                    db-user-privileges: "{$.privileges}"
                  output:
                    con: connection
              - upload-sql:
                  action: db.file-query
                  precedingPhases: [ manage-schema ]
                  parameters:
                    commandCallTimeout: 5 minutes
                    connection: "{$.con}"
                    sql-url: "{$.db-sql-url}"
            return:
              java-opts: { value: "$${{JAVA_OPTS}}" }
              uri: { value: "{$.signals.build-result.war_urls}" }
              path: { value: ["/"] }
              lib-uri:      { value: ["http://repo1.maven.org/maven2/org/apache/tomcat/dbcp/6.0.26/dbcp-6.0.26.jar", "http://repo1.maven.org/maven2/mysql/mysql-connector-java/5.1.6/mysql-connector-java-5.1.6.jar", "https://s3.amazonaws.com/qubell-starter-kit-artifacts/petclinic-deps/ojdbc6.jar"] }
              context-attrs:
                value:
                  "path": "/"
                  "debug": "5"
                  "reloadable": "true"
                  "crossContext": "true"
                  "allowLinking": "true" 
              context-nodes:
                value:
                  - Environments:
                      "name": "appEnvironment"
                      "value": "_default"
                      "type": "java.lang.String"
                      "override": "false"
                  - Resource:
                      "name": "jdbc/datasource"
                      "auth": "Container"
                      "type": "javax.sql.DataSource"
                      "maxActive": "8"
                      "maxIdle": "8"
                      "maxWait": "-1"
                      "username": "{$.con.db-user}"
                      "password": "{$.con.db-user-password}"
                      "driverClassName": "{$.con.db-driver}"
                      "url": "{$.con.connection-url}"
                      "validationQuery": "{$.con.validation-query}"
                      "testOnReturn": "true"
                      "testWhileIdle": "true"
          launch: *update
    Database:
      type: reference.Submodule
      configuration:
        __locator.application-id: "Database"
      interfaces:
        compute: &compute
          imageId:         configuration(string)
          hardwareId:      configuration(string)
          locationId:      configuration(string)
          login:           configuration(string)
        database:
          dbms:
             type: publish-signal(object)
             name: Database parameters
          #for ui only
          db-port:
             type: publish-signal(int)
             name: Database port
          db-host:
             type: publish-signal(string)
             name: Database host
          schema:
             type: receive-command(string db-user, string db-user-password, list<string> db-user-privileges => object connection)
             name: Manage schema
          file-query:
             type: receive-command(object connection, list<string> sql-url)
             name: Run a SQL query
        configuration:
          db-port:            { type: configuration(int),          name: Database listen port     }
          db-root-password:   { type: configuration(string),       name: Database root password   }
          recipe-url:         { type: configuration(string),       name: Cookbooks url            }
    LoadBalancer:
      type: reference.Submodule
      configuration:
        __locator.application-id: "Load Balancer"
      interfaces:
        compute: *compute
        servers:
          app-host: consume-signal(string)
          app-uri: consume-signal(list<string>)
        haproxy:
          stats-url: { type: publish-signal(string), name: Haproxy statistics }
          entry-urls: { type: publish-signal(list<string>), name: Entry urls         }
    BuildServer:
      type: reference.Submodule
      configuration:
        __locator.application-id: "Builder"
      interfaces:
        compute-config: *compute
        configuration:
          scm-uri:      configuration(string)
          scm-branch:   configuration(string)
        build-result:
          war_urls: publish-signal(list<string>)
    AppCluster:
      type: composite.Scaler
      components:
        AppServer:
          type: reference.Submodule
          configuration:
            __locator.application-id: "Application Server"
          interfaces:
            update-indicator:
              war-update:    consume-signal(string)
            source:
              java-opts:     consume-signal(string)
              uri:           consume-signal(list<string>)
              path:          consume-signal(list<string>)
              lib-uri:       consume-signal(list<string>)
              context-nodes: consume-signal(object)
              context-attrs: consume-signal(object)
            compute-config: *compute
            compute:
              networks:       publish-signal(map<string, map<string, string>>)
              exec:           receive-command(string command, int timeout => string stdOut, string stdErr => string stdOut, string stdErr, int exitCode)
              put-file:       receive-command(string filename, bytes payload)
              get-file:       receive-command(string filename => bytes payload)
            tomcat:
              app-host: publish-signal(string)
              app-uri: publish-signal(list<string>)
            configuration:
              app-port:     { type: configuration(int),          name: Tomcat listen port }
              java-opts:    { type: configuration(string),       name: JAVA_OPTS          }
              recipe-url:   { type: configuration(string),       name: Cookbooks url      }
